

Balance of floating points vs memory fetches

B_c = data traffic [Words] / Floating point ops [Flops]

a)
We have 2 FP per N^2 itertions = 2N^2
For every j-loop we load the elements in B, that is N elements
loaded N times. A is loaded once with a total of N^2 elements.
y can stay in register for the inner loop and is only laoded N times (neglible for large N).
Thus we have 2N^2 loads

B_c = 2N^2/2N^2 = 1


b)
We have 2N FP
For memory fetch s stays in register and we load the
elements N times. The balance is thus

B_c = N/2N = 1/2

c)
Flops = 2N
Words = 2N
B_c = 2N/2N = 1

d)
Flops = 2N
Words = (2 + 1/2)N (int is half size of double precision which constitutes a word here)
B_c = 3N/2N = 2.5/2. (This is only true when K[i] is a sequence)

Best case scenario is K[i] = const.
=> Words = (1 + 1/2)N => B_c = 0.75

Worst case scenario is that K[i] is strided such that we only
use one value from B[i] when loading an entire cache line of them.
For a cache line containing 8 words this is 8 loads for each value of B.
This gives:
Words = (1 + 1/2 + 8)N => B_c = 4.75






#
